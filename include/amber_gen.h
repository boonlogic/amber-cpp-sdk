//
// autogenerated file.  do not edit directly
//

namespace amber_models {

class PCA {
public:
  std::vector<std::vector<float>> value;

  friend void to_json(json &j, const PCA &r) { j = r.value; };

  friend void from_json(const json &j, PCA &r) {
    r.value = j.get<std::vector<std::vector<float>>>();
  };

  AMBER_DUMP()
};

class Uint64Array {
public:
  std::vector<uint64_t> value;

  friend void to_json(json &j, const Uint64Array &r) { j = r.value; };

  friend void from_json(const json &j, Uint64Array &r) {
    r.value = j.get<std::vector<uint64_t>>();
  };

  AMBER_DUMP()
};

class Uint16Array {
public:
  std::vector<uint16_t> value;

  friend void to_json(json &j, const Uint16Array &r) { j = r.value; };

  friend void from_json(const json &j, Uint16Array &r) {
    r.value = j.get<std::vector<uint16_t>>();
  };

  AMBER_DUMP()
};

class StreamingParameters {
public:
  uint32_t anomalyHistoryWindow;
  uint64_t learningRateNumerator;
  uint64_t learningRateDenominator;
  uint16_t learningMaxClusters;
  uint64_t learningMaxSamples;

  friend void to_json(json &j, const StreamingParameters &r) {
    j["anomalyHistoryWindow"] = r.anomalyHistoryWindow;
    j["learningRateNumerator"] = r.learningRateNumerator;
    j["learningRateDenominator"] = r.learningRateDenominator;
    j["learningMaxClusters"] = r.learningMaxClusters;
    j["learningMaxSamples"] = r.learningMaxSamples;
  };

  friend void from_json(const json &j, StreamingParameters &r) {
    if (j.contains("anomalyHistoryWindow") and
        !j.at("anomalyHistoryWindow").empty()) {
      r.anomalyHistoryWindow = j.at("anomalyHistoryWindow").get<uint32_t>();
    }
    if (j.contains("learningRateNumerator") and
        !j.at("learningRateNumerator").empty()) {
      r.learningRateNumerator = j.at("learningRateNumerator").get<uint64_t>();
    }
    if (j.contains("learningRateDenominator") and
        !j.at("learningRateDenominator").empty()) {
      r.learningRateDenominator =
          j.at("learningRateDenominator").get<uint64_t>();
    }
    if (j.contains("learningMaxClusters") and
        !j.at("learningMaxClusters").empty()) {
      r.learningMaxClusters = j.at("learningMaxClusters").get<uint16_t>();
    }
    if (j.contains("learningMaxSamples") and
        !j.at("learningMaxSamples").empty()) {
      r.learningMaxSamples = j.at("learningMaxSamples").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class FeatureConfig {
public:
  float maxVal;
  float minVal;
  uint16_t weight;
  std::string label;
  std::string submitRule;

  friend void to_json(json &j, const FeatureConfig &r) {
    j["maxVal"] = r.maxVal;
    j["minVal"] = r.minVal;
    j["weight"] = r.weight;
    j["label"] = r.label;
    j["submitRule"] = r.submitRule;
  };

  friend void from_json(const json &j, FeatureConfig &r) {
    if (j.contains("maxVal") and !j.at("maxVal").empty()) {
      r.maxVal = j.at("maxVal").get<float>();
    }
    if (j.contains("minVal") and !j.at("minVal").empty()) {
      r.minVal = j.at("minVal").get<float>();
    }
    if (j.contains("weight") and !j.at("weight").empty()) {
      r.weight = j.at("weight").get<uint16_t>();
    }
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("submitRule") and !j.at("submitRule").empty()) {
      r.submitRule = j.at("submitRule").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class FusionConfig {
public:
  std::string label;
  std::string submitRule;

  friend void to_json(json &j, const FusionConfig &r) {
    j["label"] = r.label;
    j["submitRule"] = r.submitRule;
  };

  friend void from_json(const json &j, FusionConfig &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("submitRule") and !j.at("submitRule").empty()) {
      r.submitRule = j.at("submitRule").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class LearningParameters {
public:
  uint64_t learningRateNumerator;
  uint64_t learningRateDenominator;
  uint16_t learningMaxClusters;
  uint64_t learningMaxSamples;

  friend void to_json(json &j, const LearningParameters &r) {
    j["learningRateNumerator"] = r.learningRateNumerator;
    j["learningRateDenominator"] = r.learningRateDenominator;
    j["learningMaxClusters"] = r.learningMaxClusters;
    j["learningMaxSamples"] = r.learningMaxSamples;
  };

  friend void from_json(const json &j, LearningParameters &r) {
    if (j.contains("learningRateNumerator") and
        !j.at("learningRateNumerator").empty()) {
      r.learningRateNumerator = j.at("learningRateNumerator").get<uint64_t>();
    }
    if (j.contains("learningRateDenominator") and
        !j.at("learningRateDenominator").empty()) {
      r.learningRateDenominator =
          j.at("learningRateDenominator").get<uint64_t>();
    }
    if (j.contains("learningMaxClusters") and
        !j.at("learningMaxClusters").empty()) {
      r.learningMaxClusters = j.at("learningMaxClusters").get<uint16_t>();
    }
    if (j.contains("learningMaxSamples") and
        !j.at("learningMaxSamples").empty()) {
      r.learningMaxSamples = j.at("learningMaxSamples").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class Float32Array {
public:
  std::vector<float> value;

  friend void to_json(json &j, const Float32Array &r) { j = r.value; };

  friend void from_json(const json &j, Float32Array &r) {
    r.value = j.get<std::vector<float>>();
  };

  AMBER_DUMP()
};

class StreamStatus {
public:
  std::string state;
  std::string message;
  uint16_t progress;
  uint32_t clusterCount;
  uint16_t retryCount;
  uint16_t streamingWindowSize;
  uint64_t totalInferences;
  uint64_t lastModified;
  uint64_t lastModifiedDelta;

  friend void to_json(json &j, const StreamStatus &r) {
    j["state"] = r.state;
    j["message"] = r.message;
    j["progress"] = r.progress;
    j["clusterCount"] = r.clusterCount;
    j["retryCount"] = r.retryCount;
    j["streamingWindowSize"] = r.streamingWindowSize;
    j["totalInferences"] = r.totalInferences;
    j["lastModified"] = r.lastModified;
    j["lastModifiedDelta"] = r.lastModifiedDelta;
  };

  friend void from_json(const json &j, StreamStatus &r) {
    if (j.contains("state") and !j.at("state").empty()) {
      r.state = j.at("state").get<std::string>();
    }
    if (j.contains("message") and !j.at("message").empty()) {
      r.message = j.at("message").get<std::string>();
    }
    if (j.contains("progress") and !j.at("progress").empty()) {
      r.progress = j.at("progress").get<uint16_t>();
    }
    if (j.contains("clusterCount") and !j.at("clusterCount").empty()) {
      r.clusterCount = j.at("clusterCount").get<uint32_t>();
    }
    if (j.contains("retryCount") and !j.at("retryCount").empty()) {
      r.retryCount = j.at("retryCount").get<uint16_t>();
    }
    if (j.contains("streamingWindowSize") and
        !j.at("streamingWindowSize").empty()) {
      r.streamingWindowSize = j.at("streamingWindowSize").get<uint16_t>();
    }
    if (j.contains("totalInferences") and !j.at("totalInferences").empty()) {
      r.totalInferences = j.at("totalInferences").get<uint64_t>();
    }
    if (j.contains("lastModified") and !j.at("lastModified").empty()) {
      r.lastModified = j.at("lastModified").get<uint64_t>();
    }
    if (j.contains("lastModifiedDelta") and
        !j.at("lastModifiedDelta").empty()) {
      r.lastModifiedDelta = j.at("lastModifiedDelta").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class PutStreamFeature {
public:
  std::string label;
  float value;
  std::string ts;

  friend void to_json(json &j, const PutStreamFeature &r) {
    j["label"] = r.label;
    j["value"] = r.value;
    j["ts"] = r.ts;
  };

  friend void from_json(const json &j, PutStreamFeature &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("value") and !j.at("value").empty()) {
      r.value = j.at("value").get<float>();
    }
    if (j.contains("ts") and !j.at("ts").empty()) {
      r.ts = j.at("ts").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class EndpointUsageInfo {
public:
  uint64_t callsTotal;
  uint64_t callsThisPeriod;
  std::string lastCalled;

  friend void to_json(json &j, const EndpointUsageInfo &r) {
    j["callsTotal"] = r.callsTotal;
    j["callsThisPeriod"] = r.callsThisPeriod;
    j["lastCalled"] = r.lastCalled;
  };

  friend void from_json(const json &j, EndpointUsageInfo &r) {
    if (j.contains("callsTotal") and !j.at("callsTotal").empty()) {
      r.callsTotal = j.at("callsTotal").get<uint64_t>();
    }
    if (j.contains("callsThisPeriod") and !j.at("callsThisPeriod").empty()) {
      r.callsThisPeriod = j.at("callsThisPeriod").get<uint64_t>();
    }
    if (j.contains("lastCalled") and !j.at("lastCalled").empty()) {
      r.lastCalled = j.at("lastCalled").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class StreamingEndpointUsageInfo {
public:
  uint64_t callsTotal;
  uint64_t callsThisPeriod;
  uint64_t samplesTotal;
  uint64_t samplesThisPeriod;
  std::string lastCalled;

  friend void to_json(json &j, const StreamingEndpointUsageInfo &r) {
    j["callsTotal"] = r.callsTotal;
    j["callsThisPeriod"] = r.callsThisPeriod;
    j["samplesTotal"] = r.samplesTotal;
    j["samplesThisPeriod"] = r.samplesThisPeriod;
    j["lastCalled"] = r.lastCalled;
  };

  friend void from_json(const json &j, StreamingEndpointUsageInfo &r) {
    if (j.contains("callsTotal") and !j.at("callsTotal").empty()) {
      r.callsTotal = j.at("callsTotal").get<uint64_t>();
    }
    if (j.contains("callsThisPeriod") and !j.at("callsThisPeriod").empty()) {
      r.callsThisPeriod = j.at("callsThisPeriod").get<uint64_t>();
    }
    if (j.contains("samplesTotal") and !j.at("samplesTotal").empty()) {
      r.samplesTotal = j.at("samplesTotal").get<uint64_t>();
    }
    if (j.contains("samplesThisPeriod") and
        !j.at("samplesThisPeriod").empty()) {
      r.samplesThisPeriod = j.at("samplesThisPeriod").get<uint64_t>();
    }
    if (j.contains("lastCalled") and !j.at("lastCalled").empty()) {
      r.lastCalled = j.at("lastCalled").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class SensorUsageInfo {
public:
  EndpointUsageInfo postConfig;
  EndpointUsageInfo postOutage;
  StreamingEndpointUsageInfo postStream;
  EndpointUsageInfo putSensor;
  EndpointUsageInfo getSensor;
  EndpointUsageInfo getConfig;
  EndpointUsageInfo getStatus;
  EndpointUsageInfo getRootCause;
  EndpointUsageInfo getAmberSummary;
  EndpointUsageInfo postPretrain;
  EndpointUsageInfo getPretrain;

  friend void to_json(json &j, const SensorUsageInfo &r) {
    j["postConfig"] = r.postConfig;
    j["postOutage"] = r.postOutage;
    j["postStream"] = r.postStream;
    j["putSensor"] = r.putSensor;
    j["getSensor"] = r.getSensor;
    j["getConfig"] = r.getConfig;
    j["getStatus"] = r.getStatus;
    j["getRootCause"] = r.getRootCause;
    j["getAmberSummary"] = r.getAmberSummary;
    j["postPretrain"] = r.postPretrain;
    j["getPretrain"] = r.getPretrain;
  };

  friend void from_json(const json &j, SensorUsageInfo &r) {
    if (j.contains("postConfig") and !j.at("postConfig").empty()) {
      r.postConfig = j.at("postConfig").get<EndpointUsageInfo>();
    }
    if (j.contains("postOutage") and !j.at("postOutage").empty()) {
      r.postOutage = j.at("postOutage").get<EndpointUsageInfo>();
    }
    if (j.contains("postStream") and !j.at("postStream").empty()) {
      r.postStream = j.at("postStream").get<StreamingEndpointUsageInfo>();
    }
    if (j.contains("putSensor") and !j.at("putSensor").empty()) {
      r.putSensor = j.at("putSensor").get<EndpointUsageInfo>();
    }
    if (j.contains("getSensor") and !j.at("getSensor").empty()) {
      r.getSensor = j.at("getSensor").get<EndpointUsageInfo>();
    }
    if (j.contains("getConfig") and !j.at("getConfig").empty()) {
      r.getConfig = j.at("getConfig").get<EndpointUsageInfo>();
    }
    if (j.contains("getStatus") and !j.at("getStatus").empty()) {
      r.getStatus = j.at("getStatus").get<EndpointUsageInfo>();
    }
    if (j.contains("getRootCause") and !j.at("getRootCause").empty()) {
      r.getRootCause = j.at("getRootCause").get<EndpointUsageInfo>();
    }
    if (j.contains("getAmberSummary") and !j.at("getAmberSummary").empty()) {
      r.getAmberSummary = j.at("getAmberSummary").get<EndpointUsageInfo>();
    }
    if (j.contains("postPretrain") and !j.at("postPretrain").empty()) {
      r.postPretrain = j.at("postPretrain").get<EndpointUsageInfo>();
    }
    if (j.contains("getPretrain") and !j.at("getPretrain").empty()) {
      r.getPretrain = j.at("getPretrain").get<EndpointUsageInfo>();
    }
  };

  AMBER_DUMP()
};

class Int32Array {
public:
  std::vector<int32_t> value;

  friend void to_json(json &j, const Int32Array &r) { j = r.value; };

  friend void from_json(const json &j, Int32Array &r) {
    r.value = j.get<std::vector<int32_t>>();
  };

  AMBER_DUMP()
};

class PostStreamResponse {
public:
  std::string state;
  std::string message;
  uint16_t progress;
  uint32_t clusterCount;
  uint16_t retryCount;
  uint16_t streamingWindowSize;
  uint64_t totalInferences;
  uint64_t lastModified;
  uint64_t lastModifiedDelta;
  Int32Array iD;
  Uint16Array rI;
  Uint16Array sI;
  Uint16Array aD;
  Uint16Array aH;
  Float32Array aM;
  Uint16Array aW;
  Uint16Array nI;
  Uint16Array nS;
  Float32Array nW;
  Float32Array oM;

  friend void to_json(json &j, const PostStreamResponse &r) {
    j["state"] = r.state;
    j["message"] = r.message;
    j["progress"] = r.progress;
    j["clusterCount"] = r.clusterCount;
    j["retryCount"] = r.retryCount;
    j["streamingWindowSize"] = r.streamingWindowSize;
    j["totalInferences"] = r.totalInferences;
    j["lastModified"] = r.lastModified;
    j["lastModifiedDelta"] = r.lastModifiedDelta;
    j["ID"] = r.iD;
    j["RI"] = r.rI;
    j["SI"] = r.sI;
    j["AD"] = r.aD;
    j["AH"] = r.aH;
    j["AM"] = r.aM;
    j["AW"] = r.aW;
    j["NI"] = r.nI;
    j["NS"] = r.nS;
    j["NW"] = r.nW;
    j["OM"] = r.oM;
  };

  friend void from_json(const json &j, PostStreamResponse &r) {
    if (j.contains("state") and !j.at("state").empty()) {
      r.state = j.at("state").get<std::string>();
    }
    if (j.contains("message") and !j.at("message").empty()) {
      r.message = j.at("message").get<std::string>();
    }
    if (j.contains("progress") and !j.at("progress").empty()) {
      r.progress = j.at("progress").get<uint16_t>();
    }
    if (j.contains("clusterCount") and !j.at("clusterCount").empty()) {
      r.clusterCount = j.at("clusterCount").get<uint32_t>();
    }
    if (j.contains("retryCount") and !j.at("retryCount").empty()) {
      r.retryCount = j.at("retryCount").get<uint16_t>();
    }
    if (j.contains("streamingWindowSize") and
        !j.at("streamingWindowSize").empty()) {
      r.streamingWindowSize = j.at("streamingWindowSize").get<uint16_t>();
    }
    if (j.contains("totalInferences") and !j.at("totalInferences").empty()) {
      r.totalInferences = j.at("totalInferences").get<uint64_t>();
    }
    if (j.contains("lastModified") and !j.at("lastModified").empty()) {
      r.lastModified = j.at("lastModified").get<uint64_t>();
    }
    if (j.contains("lastModifiedDelta") and
        !j.at("lastModifiedDelta").empty()) {
      r.lastModifiedDelta = j.at("lastModifiedDelta").get<uint64_t>();
    }
    if (j.contains("ID") and !j.at("ID").empty()) {
      r.iD = j.at("ID").get<Int32Array>();
    }
    if (j.contains("RI") and !j.at("RI").empty()) {
      r.rI = j.at("RI").get<Uint16Array>();
    }
    if (j.contains("SI") and !j.at("SI").empty()) {
      r.sI = j.at("SI").get<Uint16Array>();
    }
    if (j.contains("AD") and !j.at("AD").empty()) {
      r.aD = j.at("AD").get<Uint16Array>();
    }
    if (j.contains("AH") and !j.at("AH").empty()) {
      r.aH = j.at("AH").get<Uint16Array>();
    }
    if (j.contains("AM") and !j.at("AM").empty()) {
      r.aM = j.at("AM").get<Float32Array>();
    }
    if (j.contains("AW") and !j.at("AW").empty()) {
      r.aW = j.at("AW").get<Uint16Array>();
    }
    if (j.contains("NI") and !j.at("NI").empty()) {
      r.nI = j.at("NI").get<Uint16Array>();
    }
    if (j.contains("NS") and !j.at("NS").empty()) {
      r.nS = j.at("NS").get<Uint16Array>();
    }
    if (j.contains("NW") and !j.at("NW").empty()) {
      r.nW = j.at("NW").get<Float32Array>();
    }
    if (j.contains("OM") and !j.at("OM").empty()) {
      r.oM = j.at("OM").get<Float32Array>();
    }
  };

  AMBER_DUMP()
};

class SensorInstance {
public:
  std::string label;
  std::string sensorId;

  friend void to_json(json &j, const SensorInstance &r) {
    j["label"] = r.label;
    j["sensorId"] = r.sensorId;
  };

  friend void from_json(const json &j, SensorInstance &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("sensorId") and !j.at("sensorId").empty()) {
      r.sensorId = j.at("sensorId").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class MagicNumber {
public:
  uint16_t value;

  friend void to_json(json &j, const MagicNumber &r) { j = r.value; };

  friend void from_json(const json &j, MagicNumber &r) {
    r.value = j.get<uint16_t>();
  };

  AMBER_DUMP()
};

class VersionNumber {
public:
  uint16_t value;

  friend void to_json(json &j, const VersionNumber &r) { j = r.value; };

  friend void from_json(const json &j, VersionNumber &r) {
    r.value = j.get<uint16_t>();
  };

  AMBER_DUMP()
};

class M_NanoConfig {
public:
  VersionNumber versionNumber;
  uint16_t m_NumericFormat;
  float m_Accuracy;
  float m_PercentVariation;
  uint16_t numOfFeatures;
  std::vector<FeatureConfig> features;

  friend void to_json(json &j, const M_NanoConfig &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_NumericFormat"] = r.m_NumericFormat;
    j["m_Accuracy"] = r.m_Accuracy;
    j["m_PercentVariation"] = r.m_PercentVariation;
    j["NumOfFeatures"] = r.numOfFeatures;
    j["Features"] = r.features;
  };

  friend void from_json(const json &j, M_NanoConfig &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_NumericFormat") and !j.at("m_NumericFormat").empty()) {
      r.m_NumericFormat = j.at("m_NumericFormat").get<uint16_t>();
    }
    if (j.contains("m_Accuracy") and !j.at("m_Accuracy").empty()) {
      r.m_Accuracy = j.at("m_Accuracy").get<float>();
    }
    if (j.contains("m_PercentVariation") and
        !j.at("m_PercentVariation").empty()) {
      r.m_PercentVariation = j.at("m_PercentVariation").get<float>();
    }
    if (j.contains("NumOfFeatures") and !j.at("NumOfFeatures").empty()) {
      r.numOfFeatures = j.at("NumOfFeatures").get<uint16_t>();
    }
    if (j.contains("Features") and !j.at("Features").empty()) {
      r.features = j.at("Features").get<std::vector<FeatureConfig>>();
    }
  };

  AMBER_DUMP()
};

class M_PatternMemory {
public:
  VersionNumber versionNumber;

  friend void to_json(json &j, const M_PatternMemory &r) {
    j["VersionNumber"] = r.versionNumber;
  };

  friend void from_json(const json &j, M_PatternMemory &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
  };

  AMBER_DUMP()
};

class M_NanoBackend {
public:
  VersionNumber versionNumber;
  M_PatternMemory m_PatternMemory;
  bool m_InitComplete;
  uint16_t m_PatternLength;
  bool m_LearningIsOn;
  uint64_t m_NumOfPatternsClustered;

  friend void to_json(json &j, const M_NanoBackend &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_PatternMemory"] = r.m_PatternMemory;
    j["m_InitComplete"] = r.m_InitComplete;
    j["m_PatternLength"] = r.m_PatternLength;
    j["m_LearningIsOn"] = r.m_LearningIsOn;
    j["m_NumOfPatternsClustered"] = r.m_NumOfPatternsClustered;
  };

  friend void from_json(const json &j, M_NanoBackend &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_PatternMemory") and !j.at("m_PatternMemory").empty()) {
      r.m_PatternMemory = j.at("m_PatternMemory").get<M_PatternMemory>();
    }
    if (j.contains("m_InitComplete") and !j.at("m_InitComplete").empty()) {
      r.m_InitComplete = j.at("m_InitComplete").get<bool>();
    }
    if (j.contains("m_PatternLength") and !j.at("m_PatternLength").empty()) {
      r.m_PatternLength = j.at("m_PatternLength").get<uint16_t>();
    }
    if (j.contains("m_LearningIsOn") and !j.at("m_LearningIsOn").empty()) {
      r.m_LearningIsOn = j.at("m_LearningIsOn").get<bool>();
    }
    if (j.contains("m_NumOfPatternsClustered") and
        !j.at("m_NumOfPatternsClustered").empty()) {
      r.m_NumOfPatternsClustered =
          j.at("m_NumOfPatternsClustered").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class M_Nano {
public:
  M_NanoConfig m_NanoConfig;
  MagicNumber magicNumber;
  VersionNumber versionNumber;
  uint16_t backendVersion;
  std::string m_ErrorMsg;
  M_NanoBackend m_NanoBackend;

  friend void to_json(json &j, const M_Nano &r) {
    j["m_NanoConfig"] = r.m_NanoConfig;
    j["MagicNumber"] = r.magicNumber;
    j["VersionNumber"] = r.versionNumber;
    j["BackendVersion"] = r.backendVersion;
    j["m_ErrorMsg"] = r.m_ErrorMsg;
    j["m_NanoBackend"] = r.m_NanoBackend;
  };

  friend void from_json(const json &j, M_Nano &r) {
    if (j.contains("m_NanoConfig") and !j.at("m_NanoConfig").empty()) {
      r.m_NanoConfig = j.at("m_NanoConfig").get<M_NanoConfig>();
    }
    if (j.contains("MagicNumber") and !j.at("MagicNumber").empty()) {
      r.magicNumber = j.at("MagicNumber").get<MagicNumber>();
    }
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("BackendVersion") and !j.at("BackendVersion").empty()) {
      r.backendVersion = j.at("BackendVersion").get<uint16_t>();
    }
    if (j.contains("m_ErrorMsg") and !j.at("m_ErrorMsg").empty()) {
      r.m_ErrorMsg = j.at("m_ErrorMsg").get<std::string>();
    }
    if (j.contains("m_NanoBackend") and !j.at("m_NanoBackend").empty()) {
      r.m_NanoBackend = j.at("m_NanoBackend").get<M_NanoBackend>();
    }
  };

  AMBER_DUMP()
};

class M_BufferStats {
public:
  VersionNumber versionNumber;
  uint64_t totalBytesWritten;
  uint64_t totalBytesProcessed;
  uint64_t loadBufferLength;
  uint64_t loadBufferCapacity;

  friend void to_json(json &j, const M_BufferStats &r) {
    j["VersionNumber"] = r.versionNumber;
    j["TotalBytesWritten"] = r.totalBytesWritten;
    j["TotalBytesProcessed"] = r.totalBytesProcessed;
    j["LoadBufferLength"] = r.loadBufferLength;
    j["LoadBufferCapacity"] = r.loadBufferCapacity;
  };

  friend void from_json(const json &j, M_BufferStats &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("TotalBytesWritten") and
        !j.at("TotalBytesWritten").empty()) {
      r.totalBytesWritten = j.at("TotalBytesWritten").get<uint64_t>();
    }
    if (j.contains("TotalBytesProcessed") and
        !j.at("TotalBytesProcessed").empty()) {
      r.totalBytesProcessed = j.at("TotalBytesProcessed").get<uint64_t>();
    }
    if (j.contains("LoadBufferLength") and !j.at("LoadBufferLength").empty()) {
      r.loadBufferLength = j.at("LoadBufferLength").get<uint64_t>();
    }
    if (j.contains("LoadBufferCapacity") and
        !j.at("LoadBufferCapacity").empty()) {
      r.loadBufferCapacity = j.at("LoadBufferCapacity").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class M_NCP {
public:
  VersionNumber versionNumber;
  uint16_t numOfFeatures;
  uint16_t m_NumericFormat;
  float m_PercentVariation;
  float m_Accuracy;
  uint16_t m_StreamingWindowSize;

  friend void to_json(json &j, const M_NCP &r) {
    j["VersionNumber"] = r.versionNumber;
    j["NumOfFeatures"] = r.numOfFeatures;
    j["m_NumericFormat"] = r.m_NumericFormat;
    j["m_PercentVariation"] = r.m_PercentVariation;
    j["m_Accuracy"] = r.m_Accuracy;
    j["m_StreamingWindowSize"] = r.m_StreamingWindowSize;
  };

  friend void from_json(const json &j, M_NCP &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("NumOfFeatures") and !j.at("NumOfFeatures").empty()) {
      r.numOfFeatures = j.at("NumOfFeatures").get<uint16_t>();
    }
    if (j.contains("m_NumericFormat") and !j.at("m_NumericFormat").empty()) {
      r.m_NumericFormat = j.at("m_NumericFormat").get<uint16_t>();
    }
    if (j.contains("m_PercentVariation") and
        !j.at("m_PercentVariation").empty()) {
      r.m_PercentVariation = j.at("m_PercentVariation").get<float>();
    }
    if (j.contains("m_Accuracy") and !j.at("m_Accuracy").empty()) {
      r.m_Accuracy = j.at("m_Accuracy").get<float>();
    }
    if (j.contains("m_StreamingWindowSize") and
        !j.at("m_StreamingWindowSize").empty()) {
      r.m_StreamingWindowSize = j.at("m_StreamingWindowSize").get<uint16_t>();
    }
  };

  AMBER_DUMP()
};

class M_AP {
public:
  VersionNumber versionNumber;
  bool m_AutotuneRange;
  bool m_AutotunePV;
  bool m_AutotuneByFeatures;
  uint16_t m_MaxClusters;
  std::vector<uint16_t> m_FeaturesToTuneArray;

  friend void to_json(json &j, const M_AP &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_AutotuneRange"] = r.m_AutotuneRange;
    j["m_AutotunePV"] = r.m_AutotunePV;
    j["m_AutotuneByFeatures"] = r.m_AutotuneByFeatures;
    j["m_MaxClusters"] = r.m_MaxClusters;
    j["m_FeaturesToTuneArray"] = r.m_FeaturesToTuneArray;
  };

  friend void from_json(const json &j, M_AP &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_AutotuneRange") and !j.at("m_AutotuneRange").empty()) {
      r.m_AutotuneRange = j.at("m_AutotuneRange").get<bool>();
    }
    if (j.contains("m_AutotunePV") and !j.at("m_AutotunePV").empty()) {
      r.m_AutotunePV = j.at("m_AutotunePV").get<bool>();
    }
    if (j.contains("m_AutotuneByFeatures") and
        !j.at("m_AutotuneByFeatures").empty()) {
      r.m_AutotuneByFeatures = j.at("m_AutotuneByFeatures").get<bool>();
    }
    if (j.contains("m_MaxClusters") and !j.at("m_MaxClusters").empty()) {
      r.m_MaxClusters = j.at("m_MaxClusters").get<uint16_t>();
    }
    if (j.contains("m_FeaturesToTuneArray") and
        !j.at("m_FeaturesToTuneArray").empty()) {
      r.m_FeaturesToTuneArray =
          j.at("m_FeaturesToTuneArray").get<std::vector<uint16_t>>();
    }
  };

  AMBER_DUMP()
};

class M_Autotune {
public:
  VersionNumber versionNumber;
  bool m_AutotuningInProgress;
  int m_PercentComplete;
  bool m_AutotuningSucceeded;
  uint64_t m_NumPatternsToAutotune;
  std::string m_ErrorStringBuffer;
  std::vector<bool> m_FeaturesToTuneArray;
  M_NCP m_NCP;
  M_AP m_AP;

  friend void to_json(json &j, const M_Autotune &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_AutotuningInProgress"] = r.m_AutotuningInProgress;
    j["m_PercentComplete"] = r.m_PercentComplete;
    j["m_AutotuningSucceeded"] = r.m_AutotuningSucceeded;
    j["m_NumPatternsToAutotune"] = r.m_NumPatternsToAutotune;
    j["m_ErrorStringBuffer"] = r.m_ErrorStringBuffer;
    j["m_FeaturesToTuneArray"] = r.m_FeaturesToTuneArray;
    j["m_NCP"] = r.m_NCP;
    j["m_AP"] = r.m_AP;
  };

  friend void from_json(const json &j, M_Autotune &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_AutotuningInProgress") and
        !j.at("m_AutotuningInProgress").empty()) {
      r.m_AutotuningInProgress = j.at("m_AutotuningInProgress").get<bool>();
    }
    if (j.contains("m_PercentComplete") and
        !j.at("m_PercentComplete").empty()) {
      r.m_PercentComplete = j.at("m_PercentComplete").get<int>();
    }
    if (j.contains("m_AutotuningSucceeded") and
        !j.at("m_AutotuningSucceeded").empty()) {
      r.m_AutotuningSucceeded = j.at("m_AutotuningSucceeded").get<bool>();
    }
    if (j.contains("m_NumPatternsToAutotune") and
        !j.at("m_NumPatternsToAutotune").empty()) {
      r.m_NumPatternsToAutotune =
          j.at("m_NumPatternsToAutotune").get<uint64_t>();
    }
    if (j.contains("m_ErrorStringBuffer") and
        !j.at("m_ErrorStringBuffer").empty()) {
      r.m_ErrorStringBuffer = j.at("m_ErrorStringBuffer").get<std::string>();
    }
    if (j.contains("m_FeaturesToTuneArray") and
        !j.at("m_FeaturesToTuneArray").empty()) {
      r.m_FeaturesToTuneArray =
          j.at("m_FeaturesToTuneArray").get<std::vector<bool>>();
    }
    if (j.contains("m_NCP") and !j.at("m_NCP").empty()) {
      r.m_NCP = j.at("m_NCP").get<M_NCP>();
    }
    if (j.contains("m_AP") and !j.at("m_AP").empty()) {
      r.m_AP = j.at("m_AP").get<M_AP>();
    }
  };

  AMBER_DUMP()
};

class M_StreamingParameters {
public:
  VersionNumber versionNumber;
  bool m_EnableAutotuning;
  uint32_t m_SamplesToBufferForAutotuning;
  uint64_t m_GraduationAtRateNumerator;
  uint64_t m_GraduationAtRateDenominator;
  uint16_t m_GraduateAtMaxClusters;
  uint64_t m_GraduateAtMaxSamples;

  friend void to_json(json &j, const M_StreamingParameters &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_EnableAutotuning"] = r.m_EnableAutotuning;
    j["m_SamplesToBufferForAutotuning"] = r.m_SamplesToBufferForAutotuning;
    j["m_GraduationAtRateNumerator"] = r.m_GraduationAtRateNumerator;
    j["m_GraduationAtRateDenominator"] = r.m_GraduationAtRateDenominator;
    j["m_GraduateAtMaxClusters"] = r.m_GraduateAtMaxClusters;
    j["m_GraduateAtMaxSamples"] = r.m_GraduateAtMaxSamples;
  };

  friend void from_json(const json &j, M_StreamingParameters &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_EnableAutotuning") and
        !j.at("m_EnableAutotuning").empty()) {
      r.m_EnableAutotuning = j.at("m_EnableAutotuning").get<bool>();
    }
    if (j.contains("m_SamplesToBufferForAutotuning") and
        !j.at("m_SamplesToBufferForAutotuning").empty()) {
      r.m_SamplesToBufferForAutotuning =
          j.at("m_SamplesToBufferForAutotuning").get<uint32_t>();
    }
    if (j.contains("m_GraduationAtRateNumerator") and
        !j.at("m_GraduationAtRateNumerator").empty()) {
      r.m_GraduationAtRateNumerator =
          j.at("m_GraduationAtRateNumerator").get<uint64_t>();
    }
    if (j.contains("m_GraduationAtRateDenominator") and
        !j.at("m_GraduationAtRateDenominator").empty()) {
      r.m_GraduationAtRateDenominator =
          j.at("m_GraduationAtRateDenominator").get<uint64_t>();
    }
    if (j.contains("m_GraduateAtMaxClusters") and
        !j.at("m_GraduateAtMaxClusters").empty()) {
      r.m_GraduateAtMaxClusters =
          j.at("m_GraduateAtMaxClusters").get<uint16_t>();
    }
    if (j.contains("m_GraduateAtMaxSamples") and
        !j.at("m_GraduateAtMaxSamples").empty()) {
      r.m_GraduateAtMaxSamples = j.at("m_GraduateAtMaxSamples").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class M_AmberStatus {
public:
  VersionNumber versionNumber;
  std::string m_Status;
  std::string m_Message;
  uint16_t m_Progress;
  uint32_t m_CurrentClusterCount;
  uint16_t m_RetryCount;
  uint16_t m_StreamingWindowSize;
  uint64_t m_TotalInferences;
  uint64_t m_TotalSamplesWritten;

  friend void to_json(json &j, const M_AmberStatus &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Status"] = r.m_Status;
    j["m_Message"] = r.m_Message;
    j["m_Progress"] = r.m_Progress;
    j["m_CurrentClusterCount"] = r.m_CurrentClusterCount;
    j["m_RetryCount"] = r.m_RetryCount;
    j["m_StreamingWindowSize"] = r.m_StreamingWindowSize;
    j["m_TotalInferences"] = r.m_TotalInferences;
    j["m_TotalSamplesWritten"] = r.m_TotalSamplesWritten;
  };

  friend void from_json(const json &j, M_AmberStatus &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Status") and !j.at("m_Status").empty()) {
      r.m_Status = j.at("m_Status").get<std::string>();
    }
    if (j.contains("m_Message") and !j.at("m_Message").empty()) {
      r.m_Message = j.at("m_Message").get<std::string>();
    }
    if (j.contains("m_Progress") and !j.at("m_Progress").empty()) {
      r.m_Progress = j.at("m_Progress").get<uint16_t>();
    }
    if (j.contains("m_CurrentClusterCount") and
        !j.at("m_CurrentClusterCount").empty()) {
      r.m_CurrentClusterCount = j.at("m_CurrentClusterCount").get<uint32_t>();
    }
    if (j.contains("m_RetryCount") and !j.at("m_RetryCount").empty()) {
      r.m_RetryCount = j.at("m_RetryCount").get<uint16_t>();
    }
    if (j.contains("m_StreamingWindowSize") and
        !j.at("m_StreamingWindowSize").empty()) {
      r.m_StreamingWindowSize = j.at("m_StreamingWindowSize").get<uint16_t>();
    }
    if (j.contains("m_TotalInferences") and
        !j.at("m_TotalInferences").empty()) {
      r.m_TotalInferences = j.at("m_TotalInferences").get<uint64_t>();
    }
    if (j.contains("m_TotalSamplesWritten") and
        !j.at("m_TotalSamplesWritten").empty()) {
      r.m_TotalSamplesWritten = j.at("m_TotalSamplesWritten").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class M_Training {
public:
  std::vector<VersionNumber> versionNumber;
  std::vector<float> m_GeometricPlotY;
  std::vector<uint32_t> m_GeometricPlotX;
  std::vector<uint64_t> m_ClusterGrowth;
  std::vector<uint32_t> m_AnomalyIndexes;

  friend void to_json(json &j, const M_Training &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_GeometricPlotY"] = r.m_GeometricPlotY;
    j["m_GeometricPlotX"] = r.m_GeometricPlotX;
    j["m_ClusterGrowth"] = r.m_ClusterGrowth;
    j["m_AnomalyIndexes"] = r.m_AnomalyIndexes;
  };

  friend void from_json(const json &j, M_Training &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<std::vector<VersionNumber>>();
    }
    if (j.contains("m_GeometricPlotY") and !j.at("m_GeometricPlotY").empty()) {
      r.m_GeometricPlotY = j.at("m_GeometricPlotY").get<std::vector<float>>();
    }
    if (j.contains("m_GeometricPlotX") and !j.at("m_GeometricPlotX").empty()) {
      r.m_GeometricPlotX =
          j.at("m_GeometricPlotX").get<std::vector<uint32_t>>();
    }
    if (j.contains("m_ClusterGrowth") and !j.at("m_ClusterGrowth").empty()) {
      r.m_ClusterGrowth = j.at("m_ClusterGrowth").get<std::vector<uint64_t>>();
    }
    if (j.contains("m_AnomalyIndexes") and !j.at("m_AnomalyIndexes").empty()) {
      r.m_AnomalyIndexes =
          j.at("m_AnomalyIndexes").get<std::vector<uint32_t>>();
    }
  };

  AMBER_DUMP()
};

class M_RecentSamples {
public:
  VersionNumber versionNumber;
  std::vector<std::vector<float>> m_Values;

  friend void to_json(json &j, const M_RecentSamples &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Values"] = r.m_Values;
  };

  friend void from_json(const json &j, M_RecentSamples &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Values") and !j.at("m_Values").empty()) {
      r.m_Values = j.at("m_Values").get<std::vector<std::vector<float>>>();
    }
  };

  AMBER_DUMP()
};

class M_RecentTimes {
public:
  VersionNumber versionNumber;
  std::vector<uint64_t> m_Values;

  friend void to_json(json &j, const M_RecentTimes &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Values"] = r.m_Values;
  };

  friend void from_json(const json &j, M_RecentTimes &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Values") and !j.at("m_Values").empty()) {
      r.m_Values = j.at("m_Values").get<std::vector<uint64_t>>();
    }
  };

  AMBER_DUMP()
};

class M_RecentAnalytics {
public:
  VersionNumber versionNumber;
  std::vector<uint16_t> m_Values;

  friend void to_json(json &j, const M_RecentAnalytics &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Values"] = r.m_Values;
  };

  friend void from_json(const json &j, M_RecentAnalytics &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Values") and !j.at("m_Values").empty()) {
      r.m_Values = j.at("m_Values").get<std::vector<uint16_t>>();
    }
  };

  AMBER_DUMP()
};

class M_RecentIDs {
public:
  VersionNumber versionNumber;
  std::vector<uint32_t> m_Values;

  friend void to_json(json &j, const M_RecentIDs &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Values"] = r.m_Values;
  };

  friend void from_json(const json &j, M_RecentIDs &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Values") and !j.at("m_Values").empty()) {
      r.m_Values = j.at("m_Values").get<std::vector<uint32_t>>();
    }
  };

  AMBER_DUMP()
};

class M_RecentAMs {
public:
  VersionNumber versionNumber;
  std::vector<float> m_Values;

  friend void to_json(json &j, const M_RecentAMs &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Values"] = r.m_Values;
  };

  friend void from_json(const json &j, M_RecentAMs &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Values") and !j.at("m_Values").empty()) {
      r.m_Values = j.at("m_Values").get<std::vector<float>>();
    }
  };

  AMBER_DUMP()
};

class Version {
public:
  std::string release;
  std::string api_version;
  std::string builder;
  std::string expert_api;
  std::string expert_common;
  std::string nano_secure;
  std::string swagger_ui;

  friend void to_json(json &j, const Version &r) {
    j["release"] = r.release;
    j["api-version"] = r.api_version;
    j["builder"] = r.builder;
    j["expert-api"] = r.expert_api;
    j["expert-common"] = r.expert_common;
    j["nano-secure"] = r.nano_secure;
    j["swagger-ui"] = r.swagger_ui;
  };

  friend void from_json(const json &j, Version &r) {
    if (j.contains("release") and !j.at("release").empty()) {
      r.release = j.at("release").get<std::string>();
    }
    if (j.contains("api-version") and !j.at("api-version").empty()) {
      r.api_version = j.at("api-version").get<std::string>();
    }
    if (j.contains("builder") and !j.at("builder").empty()) {
      r.builder = j.at("builder").get<std::string>();
    }
    if (j.contains("expert-api") and !j.at("expert-api").empty()) {
      r.expert_api = j.at("expert-api").get<std::string>();
    }
    if (j.contains("expert-common") and !j.at("expert-common").empty()) {
      r.expert_common = j.at("expert-common").get<std::string>();
    }
    if (j.contains("nano-secure") and !j.at("nano-secure").empty()) {
      r.nano_secure = j.at("nano-secure").get<std::string>();
    }
    if (j.contains("swagger-ui") and !j.at("swagger-ui").empty()) {
      r.swagger_ui = j.at("swagger-ui").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PostPretrainRequest {
public:
  std::string data;
  std::string format;
  bool autotuneConfig;

  friend void to_json(json &j, const PostPretrainRequest &r) {
    j["data"] = r.data;
    j["format"] = r.format;
    j["autotuneConfig"] = r.autotuneConfig;
  };

  friend void from_json(const json &j, PostPretrainRequest &r) {
    if (j.contains("data") and !j.at("data").empty()) {
      r.data = j.at("data").get<std::string>();
    }
    if (j.contains("format") and !j.at("format").empty()) {
      r.format = j.at("format").get<std::string>();
    }
    if (j.contains("autotuneConfig") and !j.at("autotuneConfig").empty()) {
      r.autotuneConfig = j.at("autotuneConfig").get<bool>();
    }
  };

  AMBER_DUMP()
};

class PostPretrainResponse {
public:
  std::string state;
  std::string amberTransaction;
  std::string amberChunk;
  std::string message;

  friend void to_json(json &j, const PostPretrainResponse &r) {
    j["state"] = r.state;
    j["amberTransaction"] = r.amberTransaction;
    j["amberChunk"] = r.amberChunk;
    j["message"] = r.message;
  };

  friend void from_json(const json &j, PostPretrainResponse &r) {
    if (j.contains("state") and !j.at("state").empty()) {
      r.state = j.at("state").get<std::string>();
    }
    if (j.contains("amberTransaction") and !j.at("amberTransaction").empty()) {
      r.amberTransaction = j.at("amberTransaction").get<std::string>();
    }
    if (j.contains("amberChunk") and !j.at("amberChunk").empty()) {
      r.amberChunk = j.at("amberChunk").get<std::string>();
    }
    if (j.contains("message") and !j.at("message").empty()) {
      r.message = j.at("message").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class GetPretrainResponse {
public:
  std::string state;
  std::string message;

  friend void to_json(json &j, const GetPretrainResponse &r) {
    j["state"] = r.state;
    j["message"] = r.message;
  };

  friend void from_json(const json &j, GetPretrainResponse &r) {
    if (j.contains("state") and !j.at("state").empty()) {
      r.state = j.at("state").get<std::string>();
    }
    if (j.contains("message") and !j.at("message").empty()) {
      r.message = j.at("message").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class GetStatusResponse {
public:
  PCA pca;
  Uint64Array clusterGrowth;
  Uint64Array clusterSizes;
  Uint16Array anomalyIndexes;
  Uint16Array frequencyIndexes;
  Uint16Array distanceIndexes;
  uint64_t totalInferences;
  uint64_t numClusters;
  uint16_t anomalyThreshold;
  std::string state;

  friend void to_json(json &j, const GetStatusResponse &r) {
    j["pca"] = r.pca;
    j["clusterGrowth"] = r.clusterGrowth;
    j["clusterSizes"] = r.clusterSizes;
    j["anomalyIndexes"] = r.anomalyIndexes;
    j["frequencyIndexes"] = r.frequencyIndexes;
    j["distanceIndexes"] = r.distanceIndexes;
    j["totalInferences"] = r.totalInferences;
    j["numClusters"] = r.numClusters;
    j["anomalyThreshold"] = r.anomalyThreshold;
    j["state"] = r.state;
  };

  friend void from_json(const json &j, GetStatusResponse &r) {
    if (j.contains("pca") and !j.at("pca").empty()) {
      r.pca = j.at("pca").get<PCA>();
    }
    if (j.contains("clusterGrowth") and !j.at("clusterGrowth").empty()) {
      r.clusterGrowth = j.at("clusterGrowth").get<Uint64Array>();
    }
    if (j.contains("clusterSizes") and !j.at("clusterSizes").empty()) {
      r.clusterSizes = j.at("clusterSizes").get<Uint64Array>();
    }
    if (j.contains("anomalyIndexes") and !j.at("anomalyIndexes").empty()) {
      r.anomalyIndexes = j.at("anomalyIndexes").get<Uint16Array>();
    }
    if (j.contains("frequencyIndexes") and !j.at("frequencyIndexes").empty()) {
      r.frequencyIndexes = j.at("frequencyIndexes").get<Uint16Array>();
    }
    if (j.contains("distanceIndexes") and !j.at("distanceIndexes").empty()) {
      r.distanceIndexes = j.at("distanceIndexes").get<Uint16Array>();
    }
    if (j.contains("totalInferences") and !j.at("totalInferences").empty()) {
      r.totalInferences = j.at("totalInferences").get<uint64_t>();
    }
    if (j.contains("numClusters") and !j.at("numClusters").empty()) {
      r.numClusters = j.at("numClusters").get<uint64_t>();
    }
    if (j.contains("anomalyThreshold") and !j.at("anomalyThreshold").empty()) {
      r.anomalyThreshold = j.at("anomalyThreshold").get<uint16_t>();
    }
    if (j.contains("state") and !j.at("state").empty()) {
      r.state = j.at("state").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class GetConfigResponse {
public:
  uint32_t anomalyHistoryWindow;
  uint64_t learningRateNumerator;
  uint64_t learningRateDenominator;
  uint16_t learningMaxClusters;
  uint64_t learningMaxSamples;
  uint16_t featureCount;
  uint16_t streamingWindowSize;
  std::vector<FeatureConfig> features;
  float percentVariation;
  uint32_t samplesToBuffer;
  float percentVariationOverride;

  friend void to_json(json &j, const GetConfigResponse &r) {
    j["anomalyHistoryWindow"] = r.anomalyHistoryWindow;
    j["learningRateNumerator"] = r.learningRateNumerator;
    j["learningRateDenominator"] = r.learningRateDenominator;
    j["learningMaxClusters"] = r.learningMaxClusters;
    j["learningMaxSamples"] = r.learningMaxSamples;
    j["featureCount"] = r.featureCount;
    j["streamingWindowSize"] = r.streamingWindowSize;
    j["features"] = r.features;
    j["percentVariation"] = r.percentVariation;
    j["samplesToBuffer"] = r.samplesToBuffer;
    j["percentVariationOverride"] = r.percentVariationOverride;
  };

  friend void from_json(const json &j, GetConfigResponse &r) {
    if (j.contains("anomalyHistoryWindow") and
        !j.at("anomalyHistoryWindow").empty()) {
      r.anomalyHistoryWindow = j.at("anomalyHistoryWindow").get<uint32_t>();
    }
    if (j.contains("learningRateNumerator") and
        !j.at("learningRateNumerator").empty()) {
      r.learningRateNumerator = j.at("learningRateNumerator").get<uint64_t>();
    }
    if (j.contains("learningRateDenominator") and
        !j.at("learningRateDenominator").empty()) {
      r.learningRateDenominator =
          j.at("learningRateDenominator").get<uint64_t>();
    }
    if (j.contains("learningMaxClusters") and
        !j.at("learningMaxClusters").empty()) {
      r.learningMaxClusters = j.at("learningMaxClusters").get<uint16_t>();
    }
    if (j.contains("learningMaxSamples") and
        !j.at("learningMaxSamples").empty()) {
      r.learningMaxSamples = j.at("learningMaxSamples").get<uint64_t>();
    }
    if (j.contains("featureCount") and !j.at("featureCount").empty()) {
      r.featureCount = j.at("featureCount").get<uint16_t>();
    }
    if (j.contains("streamingWindowSize") and
        !j.at("streamingWindowSize").empty()) {
      r.streamingWindowSize = j.at("streamingWindowSize").get<uint16_t>();
    }
    if (j.contains("features") and !j.at("features").empty()) {
      r.features = j.at("features").get<std::vector<FeatureConfig>>();
    }
    if (j.contains("percentVariation") and !j.at("percentVariation").empty()) {
      r.percentVariation = j.at("percentVariation").get<float>();
    }
    if (j.contains("samplesToBuffer") and !j.at("samplesToBuffer").empty()) {
      r.samplesToBuffer = j.at("samplesToBuffer").get<uint32_t>();
    }
    if (j.contains("percentVariationOverride") and
        !j.at("percentVariationOverride").empty()) {
      r.percentVariationOverride =
          j.at("percentVariationOverride").get<float>();
    }
  };

  AMBER_DUMP()
};

class PutSensorRequest {
public:
  std::string label;

  friend void to_json(json &j, const PutSensorRequest &r) {
    j["label"] = r.label;
  };

  friend void from_json(const json &j, PutSensorRequest &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PutConfigRequest {
public:
  std::vector<FusionConfig> features;
  LearningParameters streaming;

  friend void to_json(json &j, const PutConfigRequest &r) {
    j["features"] = r.features;
    j["streaming"] = r.streaming;
  };

  friend void from_json(const json &j, PutConfigRequest &r) {
    if (j.contains("features") and !j.at("features").empty()) {
      r.features = j.at("features").get<std::vector<FusionConfig>>();
    }
    if (j.contains("streaming") and !j.at("streaming").empty()) {
      r.streaming = j.at("streaming").get<LearningParameters>();
    }
  };

  AMBER_DUMP()
};

class PutConfigResponse {
public:
  std::vector<FusionConfig> features;
  LearningParameters streaming;

  friend void to_json(json &j, const PutConfigResponse &r) {
    j["features"] = r.features;
    j["streaming"] = r.streaming;
  };

  friend void from_json(const json &j, PutConfigResponse &r) {
    if (j.contains("features") and !j.at("features").empty()) {
      r.features = j.at("features").get<std::vector<FusionConfig>>();
    }
    if (j.contains("streaming") and !j.at("streaming").empty()) {
      r.streaming = j.at("streaming").get<LearningParameters>();
    }
  };

  AMBER_DUMP()
};

class PostConfigRequest {
public:
  uint32_t anomalyHistoryWindow;
  uint64_t learningRateNumerator;
  uint64_t learningRateDenominator;
  uint16_t learningMaxClusters;
  uint64_t learningMaxSamples;
  uint16_t featureCount;
  uint16_t streamingWindowSize;
  std::vector<FeatureConfig> features;
  uint32_t samplesToBuffer;
  float percentVariationOverride;

  friend void to_json(json &j, const PostConfigRequest &r) {
    j["anomalyHistoryWindow"] = r.anomalyHistoryWindow;
    j["learningRateNumerator"] = r.learningRateNumerator;
    j["learningRateDenominator"] = r.learningRateDenominator;
    j["learningMaxClusters"] = r.learningMaxClusters;
    j["learningMaxSamples"] = r.learningMaxSamples;
    j["featureCount"] = r.featureCount;
    j["streamingWindowSize"] = r.streamingWindowSize;
    j["features"] = r.features;
    j["samplesToBuffer"] = r.samplesToBuffer;
    j["percentVariationOverride"] = r.percentVariationOverride;
  };

  friend void from_json(const json &j, PostConfigRequest &r) {
    if (j.contains("anomalyHistoryWindow") and
        !j.at("anomalyHistoryWindow").empty()) {
      r.anomalyHistoryWindow = j.at("anomalyHistoryWindow").get<uint32_t>();
    }
    if (j.contains("learningRateNumerator") and
        !j.at("learningRateNumerator").empty()) {
      r.learningRateNumerator = j.at("learningRateNumerator").get<uint64_t>();
    }
    if (j.contains("learningRateDenominator") and
        !j.at("learningRateDenominator").empty()) {
      r.learningRateDenominator =
          j.at("learningRateDenominator").get<uint64_t>();
    }
    if (j.contains("learningMaxClusters") and
        !j.at("learningMaxClusters").empty()) {
      r.learningMaxClusters = j.at("learningMaxClusters").get<uint16_t>();
    }
    if (j.contains("learningMaxSamples") and
        !j.at("learningMaxSamples").empty()) {
      r.learningMaxSamples = j.at("learningMaxSamples").get<uint64_t>();
    }
    if (j.contains("featureCount") and !j.at("featureCount").empty()) {
      r.featureCount = j.at("featureCount").get<uint16_t>();
    }
    if (j.contains("streamingWindowSize") and
        !j.at("streamingWindowSize").empty()) {
      r.streamingWindowSize = j.at("streamingWindowSize").get<uint16_t>();
    }
    if (j.contains("features") and !j.at("features").empty()) {
      r.features = j.at("features").get<std::vector<FeatureConfig>>();
    }
    if (j.contains("samplesToBuffer") and !j.at("samplesToBuffer").empty()) {
      r.samplesToBuffer = j.at("samplesToBuffer").get<uint32_t>();
    }
    if (j.contains("percentVariationOverride") and
        !j.at("percentVariationOverride").empty()) {
      r.percentVariationOverride =
          j.at("percentVariationOverride").get<float>();
    }
  };

  AMBER_DUMP()
};

class GetRootCauseResponse {
public:
  std::vector<Float32Array> value;

  friend void to_json(json &j, const GetRootCauseResponse &r) { j = r.value; };

  friend void from_json(const json &j, GetRootCauseResponse &r) {
    r.value = j.get<std::vector<Float32Array>>();
  };

  AMBER_DUMP()
};

class Error {
public:
  uint16_t code;
  std::string message;

  friend void to_json(json &j, const Error &r) {
    j["code"] = r.code;
    j["message"] = r.message;
  };

  friend void from_json(const json &j, Error &r) {
    if (j.contains("code") and !j.at("code").empty()) {
      r.code = j.at("code").get<uint16_t>();
    }
    if (j.contains("message") and !j.at("message").empty()) {
      r.message = j.at("message").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PostAuth2Request {
public:
  std::string username;
  std::string password;

  friend void to_json(json &j, const PostAuth2Request &r) {
    j["username"] = r.username;
    j["password"] = r.password;
  };

  friend void from_json(const json &j, PostAuth2Request &r) {
    if (j.contains("username") and !j.at("username").empty()) {
      r.username = j.at("username").get<std::string>();
    }
    if (j.contains("password") and !j.at("password").empty()) {
      r.password = j.at("password").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PostOutageResponse {
public:
  std::string state;
  std::string message;
  uint16_t progress;
  uint32_t clusterCount;
  uint16_t retryCount;
  uint16_t streamingWindowSize;
  uint64_t totalInferences;
  uint64_t lastModified;
  uint64_t lastModifiedDelta;

  friend void to_json(json &j, const PostOutageResponse &r) {
    j["state"] = r.state;
    j["message"] = r.message;
    j["progress"] = r.progress;
    j["clusterCount"] = r.clusterCount;
    j["retryCount"] = r.retryCount;
    j["streamingWindowSize"] = r.streamingWindowSize;
    j["totalInferences"] = r.totalInferences;
    j["lastModified"] = r.lastModified;
    j["lastModifiedDelta"] = r.lastModifiedDelta;
  };

  friend void from_json(const json &j, PostOutageResponse &r) {
    if (j.contains("state") and !j.at("state").empty()) {
      r.state = j.at("state").get<std::string>();
    }
    if (j.contains("message") and !j.at("message").empty()) {
      r.message = j.at("message").get<std::string>();
    }
    if (j.contains("progress") and !j.at("progress").empty()) {
      r.progress = j.at("progress").get<uint16_t>();
    }
    if (j.contains("clusterCount") and !j.at("clusterCount").empty()) {
      r.clusterCount = j.at("clusterCount").get<uint32_t>();
    }
    if (j.contains("retryCount") and !j.at("retryCount").empty()) {
      r.retryCount = j.at("retryCount").get<uint16_t>();
    }
    if (j.contains("streamingWindowSize") and
        !j.at("streamingWindowSize").empty()) {
      r.streamingWindowSize = j.at("streamingWindowSize").get<uint16_t>();
    }
    if (j.contains("totalInferences") and !j.at("totalInferences").empty()) {
      r.totalInferences = j.at("totalInferences").get<uint64_t>();
    }
    if (j.contains("lastModified") and !j.at("lastModified").empty()) {
      r.lastModified = j.at("lastModified").get<uint64_t>();
    }
    if (j.contains("lastModifiedDelta") and
        !j.at("lastModifiedDelta").empty()) {
      r.lastModifiedDelta = j.at("lastModifiedDelta").get<uint64_t>();
    }
  };

  AMBER_DUMP()
};

class PostSensorResponse {
public:
  std::string label;
  std::string sensorId;

  friend void to_json(json &j, const PostSensorResponse &r) {
    j["label"] = r.label;
    j["sensorId"] = r.sensorId;
  };

  friend void from_json(const json &j, PostSensorResponse &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("sensorId") and !j.at("sensorId").empty()) {
      r.sensorId = j.at("sensorId").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PutSensorResponse {
public:
  std::string label;
  std::string sensorId;

  friend void to_json(json &j, const PutSensorResponse &r) {
    j["label"] = r.label;
    j["sensorId"] = r.sensorId;
  };

  friend void from_json(const json &j, PutSensorResponse &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("sensorId") and !j.at("sensorId").empty()) {
      r.sensorId = j.at("sensorId").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PostStreamRequest {
public:
  bool saveImage;
  std::string data;

  friend void to_json(json &j, const PostStreamRequest &r) {
    j["saveImage"] = r.saveImage;
    j["data"] = r.data;
  };

  friend void from_json(const json &j, PostStreamRequest &r) {
    if (j.contains("saveImage") and !j.at("saveImage").empty()) {
      r.saveImage = j.at("saveImage").get<bool>();
    }
    if (j.contains("data") and !j.at("data").empty()) {
      r.data = j.at("data").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PutStreamRequest {
public:
  std::vector<PutStreamFeature> vector;
  std::string submitRule;

  friend void to_json(json &j, const PutStreamRequest &r) {
    j["vector"] = r.vector;
    j["submitRule"] = r.submitRule;
  };

  friend void from_json(const json &j, PutStreamRequest &r) {
    if (j.contains("vector") and !j.at("vector").empty()) {
      r.vector = j.at("vector").get<std::vector<PutStreamFeature>>();
    }
    if (j.contains("submitRule") and !j.at("submitRule").empty()) {
      r.submitRule = j.at("submitRule").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class GetSensorResponse {
public:
  std::string label;
  std::string sensorId;
  SensorUsageInfo usageInfo;

  friend void to_json(json &j, const GetSensorResponse &r) {
    j["label"] = r.label;
    j["sensorId"] = r.sensorId;
    j["usageInfo"] = r.usageInfo;
  };

  friend void from_json(const json &j, GetSensorResponse &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
    if (j.contains("sensorId") and !j.at("sensorId").empty()) {
      r.sensorId = j.at("sensorId").get<std::string>();
    }
    if (j.contains("usageInfo") and !j.at("usageInfo").empty()) {
      r.usageInfo = j.at("usageInfo").get<SensorUsageInfo>();
    }
  };

  AMBER_DUMP()
};

class Uint32Array {
public:
  std::vector<uint32_t> value;

  friend void to_json(json &j, const Uint32Array &r) { j = r.value; };

  friend void from_json(const json &j, Uint32Array &r) {
    r.value = j.get<std::vector<uint32_t>>();
  };

  AMBER_DUMP()
};

class PostAuth2Response {
public:
  std::string idToken;
  std::string refreshToken;
  std::string expiresIn;
  std::string tokenType;

  friend void to_json(json &j, const PostAuth2Response &r) {
    j["idToken"] = r.idToken;
    j["refreshToken"] = r.refreshToken;
    j["expiresIn"] = r.expiresIn;
    j["tokenType"] = r.tokenType;
  };

  friend void from_json(const json &j, PostAuth2Response &r) {
    if (j.contains("idToken") and !j.at("idToken").empty()) {
      r.idToken = j.at("idToken").get<std::string>();
    }
    if (j.contains("refreshToken") and !j.at("refreshToken").empty()) {
      r.refreshToken = j.at("refreshToken").get<std::string>();
    }
    if (j.contains("expiresIn") and !j.at("expiresIn").empty()) {
      r.expiresIn = j.at("expiresIn").get<std::string>();
    }
    if (j.contains("tokenType") and !j.at("tokenType").empty()) {
      r.tokenType = j.at("tokenType").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class PutStreamResponse {
public:
  std::string vector;
  PostStreamResponse results;

  friend void to_json(json &j, const PutStreamResponse &r) {
    j["vector"] = r.vector;
    j["results"] = r.results;
  };

  friend void from_json(const json &j, PutStreamResponse &r) {
    if (j.contains("vector") and !j.at("vector").empty()) {
      r.vector = j.at("vector").get<std::string>();
    }
    if (j.contains("results") and !j.at("results").empty()) {
      r.results = j.at("results").get<PostStreamResponse>();
    }
  };

  AMBER_DUMP()
};

class PostConfigResponse {
public:
  uint32_t anomalyHistoryWindow;
  uint64_t learningRateNumerator;
  uint64_t learningRateDenominator;
  uint16_t learningMaxClusters;
  uint64_t learningMaxSamples;
  uint16_t featureCount;
  uint16_t streamingWindowSize;
  std::vector<FeatureConfig> features;
  uint32_t samplesToBuffer;
  float percentVariationOverride;

  friend void to_json(json &j, const PostConfigResponse &r) {
    j["anomalyHistoryWindow"] = r.anomalyHistoryWindow;
    j["learningRateNumerator"] = r.learningRateNumerator;
    j["learningRateDenominator"] = r.learningRateDenominator;
    j["learningMaxClusters"] = r.learningMaxClusters;
    j["learningMaxSamples"] = r.learningMaxSamples;
    j["featureCount"] = r.featureCount;
    j["streamingWindowSize"] = r.streamingWindowSize;
    j["features"] = r.features;
    j["samplesToBuffer"] = r.samplesToBuffer;
    j["percentVariationOverride"] = r.percentVariationOverride;
  };

  friend void from_json(const json &j, PostConfigResponse &r) {
    if (j.contains("anomalyHistoryWindow") and
        !j.at("anomalyHistoryWindow").empty()) {
      r.anomalyHistoryWindow = j.at("anomalyHistoryWindow").get<uint32_t>();
    }
    if (j.contains("learningRateNumerator") and
        !j.at("learningRateNumerator").empty()) {
      r.learningRateNumerator = j.at("learningRateNumerator").get<uint64_t>();
    }
    if (j.contains("learningRateDenominator") and
        !j.at("learningRateDenominator").empty()) {
      r.learningRateDenominator =
          j.at("learningRateDenominator").get<uint64_t>();
    }
    if (j.contains("learningMaxClusters") and
        !j.at("learningMaxClusters").empty()) {
      r.learningMaxClusters = j.at("learningMaxClusters").get<uint16_t>();
    }
    if (j.contains("learningMaxSamples") and
        !j.at("learningMaxSamples").empty()) {
      r.learningMaxSamples = j.at("learningMaxSamples").get<uint64_t>();
    }
    if (j.contains("featureCount") and !j.at("featureCount").empty()) {
      r.featureCount = j.at("featureCount").get<uint16_t>();
    }
    if (j.contains("streamingWindowSize") and
        !j.at("streamingWindowSize").empty()) {
      r.streamingWindowSize = j.at("streamingWindowSize").get<uint16_t>();
    }
    if (j.contains("features") and !j.at("features").empty()) {
      r.features = j.at("features").get<std::vector<FeatureConfig>>();
    }
    if (j.contains("samplesToBuffer") and !j.at("samplesToBuffer").empty()) {
      r.samplesToBuffer = j.at("samplesToBuffer").get<uint32_t>();
    }
    if (j.contains("percentVariationOverride") and
        !j.at("percentVariationOverride").empty()) {
      r.percentVariationOverride =
          j.at("percentVariationOverride").get<float>();
    }
  };

  AMBER_DUMP()
};

class PostSensorRequest {
public:
  std::string label;

  friend void to_json(json &j, const PostSensorRequest &r) {
    j["label"] = r.label;
  };

  friend void from_json(const json &j, PostSensorRequest &r) {
    if (j.contains("label") and !j.at("label").empty()) {
      r.label = j.at("label").get<std::string>();
    }
  };

  AMBER_DUMP()
};

class GetSensorsResponse {
public:
  std::vector<SensorInstance> value;

  friend void to_json(json &j, const GetSensorsResponse &r) { j = r.value; };

  friend void from_json(const json &j, GetSensorsResponse &r) {
    r.value = j.get<std::vector<SensorInstance>>();
  };

  AMBER_DUMP()
};

class GetSummaryResponse {
public:
  MagicNumber magicNumber;
  VersionNumber versionNumber;
  M_Nano m_Nano;
  M_BufferStats m_BufferStats;
  M_Autotune m_Autotune;
  std::vector<uint16_t> m_AutotuningElbowClusterCounts;
  std::vector<float> m_AutotuningElbowPVArray;
  M_StreamingParameters m_StreamingParameters;
  M_AmberStatus m_AmberStatus;
  M_Training m_Training;
  uint16_t m_AnomalyThreshold;
  uint64_t m_AmberWarningCriticalValue;
  uint64_t m_AmberAlertCriticalValue;
  std::string m_ErrorStringBuffer;
  bool m_ClusteringParametersInitialized;
  bool m_StreamingMode;
  uint16_t m_StreamingModeStatus;
  uint64_t m_ModifiedAt;
  std::vector<float> m_AnomalyMetricByAnomalyCount;
  uint16_t m_RecentAnomalyCount;
  std::vector<uint32_t> m_ResultsIDArray;
  M_RecentSamples m_TrainingSamples;
  M_RecentSamples m_RecentSamples;
  M_RecentSamples m_RecentRawSamples;
  M_RecentTimes m_RecentTimes;
  M_RecentAnalytics m_RecentSIs;
  M_RecentAnalytics m_RecentRIs;
  M_RecentAnalytics m_RecentADs;
  M_RecentAnalytics m_RecentAHs;
  M_RecentIDs m_RecentIDs;
  M_RecentAMs m_RecentAMs;
  M_RecentAnalytics m_RecentAWs;

  friend void to_json(json &j, const GetSummaryResponse &r) {
    j["MagicNumber"] = r.magicNumber;
    j["VersionNumber"] = r.versionNumber;
    j["m_Nano"] = r.m_Nano;
    j["m_BufferStats"] = r.m_BufferStats;
    j["m_Autotune"] = r.m_Autotune;
    j["m_AutotuningElbowClusterCounts"] = r.m_AutotuningElbowClusterCounts;
    j["m_AutotuningElbowPVArray"] = r.m_AutotuningElbowPVArray;
    j["m_StreamingParameters"] = r.m_StreamingParameters;
    j["m_AmberStatus"] = r.m_AmberStatus;
    j["m_Training"] = r.m_Training;
    j["m_AnomalyThreshold"] = r.m_AnomalyThreshold;
    j["m_AmberWarningCriticalValue"] = r.m_AmberWarningCriticalValue;
    j["m_AmberAlertCriticalValue"] = r.m_AmberAlertCriticalValue;
    j["m_ErrorStringBuffer"] = r.m_ErrorStringBuffer;
    j["m_ClusteringParametersInitialized"] =
        r.m_ClusteringParametersInitialized;
    j["m_StreamingMode"] = r.m_StreamingMode;
    j["m_StreamingModeStatus"] = r.m_StreamingModeStatus;
    j["m_ModifiedAt"] = r.m_ModifiedAt;
    j["m_AnomalyMetricByAnomalyCount"] = r.m_AnomalyMetricByAnomalyCount;
    j["m_RecentAnomalyCount"] = r.m_RecentAnomalyCount;
    j["m_ResultsIDArray"] = r.m_ResultsIDArray;
    j["m_TrainingSamples"] = r.m_TrainingSamples;
    j["m_RecentSamples"] = r.m_RecentSamples;
    j["m_RecentRawSamples"] = r.m_RecentRawSamples;
    j["m_RecentTimes"] = r.m_RecentTimes;
    j["m_RecentSIs"] = r.m_RecentSIs;
    j["m_RecentRIs"] = r.m_RecentRIs;
    j["m_RecentADs"] = r.m_RecentADs;
    j["m_RecentAHs"] = r.m_RecentAHs;
    j["m_RecentIDs"] = r.m_RecentIDs;
    j["m_RecentAMs"] = r.m_RecentAMs;
    j["m_RecentAWs"] = r.m_RecentAWs;
  };

  friend void from_json(const json &j, GetSummaryResponse &r) {
    if (j.contains("MagicNumber") and !j.at("MagicNumber").empty()) {
      r.magicNumber = j.at("MagicNumber").get<MagicNumber>();
    }
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Nano") and !j.at("m_Nano").empty()) {
      r.m_Nano = j.at("m_Nano").get<M_Nano>();
    }
    if (j.contains("m_BufferStats") and !j.at("m_BufferStats").empty()) {
      r.m_BufferStats = j.at("m_BufferStats").get<M_BufferStats>();
    }
    if (j.contains("m_Autotune") and !j.at("m_Autotune").empty()) {
      r.m_Autotune = j.at("m_Autotune").get<M_Autotune>();
    }
    if (j.contains("m_AutotuningElbowClusterCounts") and
        !j.at("m_AutotuningElbowClusterCounts").empty()) {
      r.m_AutotuningElbowClusterCounts =
          j.at("m_AutotuningElbowClusterCounts").get<std::vector<uint16_t>>();
    }
    if (j.contains("m_AutotuningElbowPVArray") and
        !j.at("m_AutotuningElbowPVArray").empty()) {
      r.m_AutotuningElbowPVArray =
          j.at("m_AutotuningElbowPVArray").get<std::vector<float>>();
    }
    if (j.contains("m_StreamingParameters") and
        !j.at("m_StreamingParameters").empty()) {
      r.m_StreamingParameters =
          j.at("m_StreamingParameters").get<M_StreamingParameters>();
    }
    if (j.contains("m_AmberStatus") and !j.at("m_AmberStatus").empty()) {
      r.m_AmberStatus = j.at("m_AmberStatus").get<M_AmberStatus>();
    }
    if (j.contains("m_Training") and !j.at("m_Training").empty()) {
      r.m_Training = j.at("m_Training").get<M_Training>();
    }
    if (j.contains("m_AnomalyThreshold") and
        !j.at("m_AnomalyThreshold").empty()) {
      r.m_AnomalyThreshold = j.at("m_AnomalyThreshold").get<uint16_t>();
    }
    if (j.contains("m_AmberWarningCriticalValue") and
        !j.at("m_AmberWarningCriticalValue").empty()) {
      r.m_AmberWarningCriticalValue =
          j.at("m_AmberWarningCriticalValue").get<uint64_t>();
    }
    if (j.contains("m_AmberAlertCriticalValue") and
        !j.at("m_AmberAlertCriticalValue").empty()) {
      r.m_AmberAlertCriticalValue =
          j.at("m_AmberAlertCriticalValue").get<uint64_t>();
    }
    if (j.contains("m_ErrorStringBuffer") and
        !j.at("m_ErrorStringBuffer").empty()) {
      r.m_ErrorStringBuffer = j.at("m_ErrorStringBuffer").get<std::string>();
    }
    if (j.contains("m_ClusteringParametersInitialized") and
        !j.at("m_ClusteringParametersInitialized").empty()) {
      r.m_ClusteringParametersInitialized =
          j.at("m_ClusteringParametersInitialized").get<bool>();
    }
    if (j.contains("m_StreamingMode") and !j.at("m_StreamingMode").empty()) {
      r.m_StreamingMode = j.at("m_StreamingMode").get<bool>();
    }
    if (j.contains("m_StreamingModeStatus") and
        !j.at("m_StreamingModeStatus").empty()) {
      r.m_StreamingModeStatus = j.at("m_StreamingModeStatus").get<uint16_t>();
    }
    if (j.contains("m_ModifiedAt") and !j.at("m_ModifiedAt").empty()) {
      r.m_ModifiedAt = j.at("m_ModifiedAt").get<uint64_t>();
    }
    if (j.contains("m_AnomalyMetricByAnomalyCount") and
        !j.at("m_AnomalyMetricByAnomalyCount").empty()) {
      r.m_AnomalyMetricByAnomalyCount =
          j.at("m_AnomalyMetricByAnomalyCount").get<std::vector<float>>();
    }
    if (j.contains("m_RecentAnomalyCount") and
        !j.at("m_RecentAnomalyCount").empty()) {
      r.m_RecentAnomalyCount = j.at("m_RecentAnomalyCount").get<uint16_t>();
    }
    if (j.contains("m_ResultsIDArray") and !j.at("m_ResultsIDArray").empty()) {
      r.m_ResultsIDArray =
          j.at("m_ResultsIDArray").get<std::vector<uint32_t>>();
    }
    if (j.contains("m_TrainingSamples") and
        !j.at("m_TrainingSamples").empty()) {
      r.m_TrainingSamples = j.at("m_TrainingSamples").get<M_RecentSamples>();
    }
    if (j.contains("m_RecentSamples") and !j.at("m_RecentSamples").empty()) {
      r.m_RecentSamples = j.at("m_RecentSamples").get<M_RecentSamples>();
    }
    if (j.contains("m_RecentRawSamples") and
        !j.at("m_RecentRawSamples").empty()) {
      r.m_RecentRawSamples = j.at("m_RecentRawSamples").get<M_RecentSamples>();
    }
    if (j.contains("m_RecentTimes") and !j.at("m_RecentTimes").empty()) {
      r.m_RecentTimes = j.at("m_RecentTimes").get<M_RecentTimes>();
    }
    if (j.contains("m_RecentSIs") and !j.at("m_RecentSIs").empty()) {
      r.m_RecentSIs = j.at("m_RecentSIs").get<M_RecentAnalytics>();
    }
    if (j.contains("m_RecentRIs") and !j.at("m_RecentRIs").empty()) {
      r.m_RecentRIs = j.at("m_RecentRIs").get<M_RecentAnalytics>();
    }
    if (j.contains("m_RecentADs") and !j.at("m_RecentADs").empty()) {
      r.m_RecentADs = j.at("m_RecentADs").get<M_RecentAnalytics>();
    }
    if (j.contains("m_RecentAHs") and !j.at("m_RecentAHs").empty()) {
      r.m_RecentAHs = j.at("m_RecentAHs").get<M_RecentAnalytics>();
    }
    if (j.contains("m_RecentIDs") and !j.at("m_RecentIDs").empty()) {
      r.m_RecentIDs = j.at("m_RecentIDs").get<M_RecentIDs>();
    }
    if (j.contains("m_RecentAMs") and !j.at("m_RecentAMs").empty()) {
      r.m_RecentAMs = j.at("m_RecentAMs").get<M_RecentAMs>();
    }
    if (j.contains("m_RecentAWs") and !j.at("m_RecentAWs").empty()) {
      r.m_RecentAWs = j.at("m_RecentAWs").get<M_RecentAnalytics>();
    }
  };

  AMBER_DUMP()
};

class M_RecentFloats {
public:
  VersionNumber versionNumber;
  std::vector<float> m_Values;

  friend void to_json(json &j, const M_RecentFloats &r) {
    j["VersionNumber"] = r.versionNumber;
    j["m_Values"] = r.m_Values;
  };

  friend void from_json(const json &j, M_RecentFloats &r) {
    if (j.contains("VersionNumber") and !j.at("VersionNumber").empty()) {
      r.versionNumber = j.at("VersionNumber").get<VersionNumber>();
    }
    if (j.contains("m_Values") and !j.at("m_Values").empty()) {
      r.m_Values = j.at("m_Values").get<std::vector<float>>();
    }
  };

  AMBER_DUMP()
};
} // namespace amber_models
